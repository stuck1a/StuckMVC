<?php/* * This file is part of StuckMVC <https://stuck1a.de/coding/stuckmvc>, * Copyright (c) 2021. * StuckMVC framework is free software: you can redistribute it and/or modify it * under the terms of the GNU General Public License version 3 as published by * the Free Software Foundation. *  * It is distributed in the hope that it will be useful, but without any warranty; * without even the implied warranty of merchantability of fitness for a * particular purpose. See the GNU General Public License for more details. * * You should have received a copy of the GNU General Public License along with * StuckMVC. If not, see <https://www.gnu.org/licenses/>.  * * FOR A SOMEWHAT FREER WORLD. */namespace Stuck1A\StuckMVC;use Stuck1A\StuckMVC\Core\Autoloader\Autoloader;use Stuck1A\StuckMVC\Core\Application;/** * Internal Error Handler<br><br> *  * Manages the output of error message regarding to the configured reporting level but also works as last resort * exception handling. It will handle all thrown fatal errors, which couldn't get caught. Since the application already * crashed then, the last what we can do then, is to render some fallback output. * First it will search for the theme's offline page, then for the global one. If all this won't work, there must be * major trouble with config, setup or the received request, so only chance is to directly output as final resort.<br><br> * <b>Note:</b><br> * <i>This Handler doesn't care about its output. It will do what you've configured it to do. * So be aware that it might output sensitive data, if you've set 'php_error_reporting' to * E_ALL in configs.php or in the experts section of the admin backend in a live environment.</i> * * @param  int     $errno      error type * @param  string  $errstr     error message * @param  ?string $errfile    error files realpath * @param  ?int    $errline    error line * @param  ?array  $errcontent error content (for older php versions) * * @return bool    true if no fatal error occurred and execution can go on */function onError(int $errno, string $errstr, string $errfile = null, int $errline = null, array $errcontent = null): bool {  // FATAL_ERROR - say nope as nice as possible and invoke the shutdown handler  if ( $errno === E_ERROR || $errno === E_CORE_ERROR || $errno === E_COMPILE_ERROR ) {    $protocol = 'https';    // use secured https protocol as a fallback (e.g. for php-cli)    try {      // most failsafe way to redirect is absolute, so get the active protocol in a bulletproof way      $protocol = $_SERVER['REQUEST_SCHEME'] ?? strtolower(explode('/', $_SERVER['SERVER_PROTOCOL'])[0]);      // redirect to the themes offline page, if locatable      // TODO: Versuche den Themepfad zu kriegen      header('Location: ' . $protocol . '://' . $_SERVER['SERVER_NAME'] . rtrim(dirname($_SERVER['PHP_SELF']), '/\\') . '/mvc/views/classic/offline.html');    } catch ( \Exception $e ) {      try {        // next we will try to use the global fallback offline page        header('Location: ' . $protocol . '://' . $_SERVER['SERVER_NAME'] . rtrim(dirname($_SERVER['PHP_SELF']), '/\\') . "/offline.html");      } catch ( \Exception $e ) {        // seems like something went terribly wrong. Output at least some minimalistic offline page directly from script        print_r('This website is currently offline. Please apologize any inconveniences.');      }    }    die();  }  // for non-fatal errors output error message if reporting of occurred error type is configured and continue execution  switch ( $errno ) {    case E_STRICT:      print '<b>E_STRICT:</b> ' . htmlspecialchars($errstr) . ' | occurred@(' . $errline . ')' . $errfile . ($errcontent??'') . '<br><br>';      return true;    case E_PARSE:      print '<b>E_PARSE:</b> ' . htmlspecialchars($errstr) . ' | occurred@(' . $errline . ')' . $errfile . ($errcontent??'') . '<br><br>';      return true;    case E_WARNING:      print '<b>E_WARNING:</b> ' . htmlspecialchars($errstr) . ' | occurred@(' . $errline . ')' . $errfile . ($errcontent??'') . '<br><br>';      return true;    case E_NOTICE:      print '<b>E_NOTICE:</b> ' . htmlspecialchars($errstr) . ' | occurred@(' . $errline . ')' . $errfile . ($errcontent??'') . '<br><br>';      return true;    default:      print '<b>UNKNOWN:</b> ' . htmlspecialchars($errstr) . ' | occurred@(' . $errline . ')' . $errfile . ($errcontent??'') . '<br><br>';      return true;  }}set_error_handler(__NAMESPACE__ . '\\onError');// set up the autoloader queue (framework -> smarty -> composer)require './vendor/autoload.php';require './vendor/smarty/smarty/libs/bootstrap.php';require './core/autoloader/Autoloader.php';Autoloader::register('classmap', true);// boot and run the application(new Application)->start();